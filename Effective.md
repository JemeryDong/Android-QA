[https://zhuanlan.zhihu.com/p/24490196](https://zhuanlan.zhihu.com/p/24490196)

#### 强制不可实例化

如果你不希望一个对象通过关键字 *new* 来创建，那么强制让它的**构造方法私有**。这尤其对一些只包含静态方法的工具类有用。

```java
class MovieUtils {
  private MovieUtils() {}

    static String titleAndYear(Movie movie) {
        [...]
    }
}
```

#### 1.静态工厂方法

不要使用new关键字和构造方法创建对象，而应当使用静态工厂方法（和私有构造方法）。这些工厂方法具有名字，需要每次返回一个新的对象实例，它们可以根据需求返回不同的子类型对象。

##### 优点

1. 静态工厂方法与构造器不同的优势，它们是有名称的

2. 不必在每次调用它们的时候都创建一个新对象

3. 它们可以返回原返回类型任何子类型的对象（增加了灵活性）

4. 在创建参数化类型实例的时候，它们使得代码变得更加简洁

##### 缺点

1. 类如果不含共有的或者受保护的构造器，就不能被子类化。

2. 它们与其他静态方法实际上没有任何区别

   遵守标准的命名习惯，一定量可以弥补这一劣势。

   - valueOf——这样的静态工厂方法实际上是类型转换方法。
   - of——valueOf的一种更为简洁的替代。
   - getInstance——返回的实例是通过方法的参数来描述的，但是不能够说与参数具有同样的值。对于Singleton来说，该方法没有参数，并返回唯一的实例。
   - newInstance——像getInstance一样，但newInstance能够确保返回的每个实例都与所有其他实例不同。
   - getType——像getInstance一样，但在工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型。
   - newType——像newInstance一样，但是工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型

   ​

```java
class Movie {
    [...]
    public static Movie create(String title) {
        return new Movie(title);
    }
}
```

#### 2.创建者模式

当对象的构造方法参数不小于3个时，可以考虑创建者模式。这可能需要更多行代码，但扩展性和可读性会很好。如果你正创建一个实体类。

##### 缺点

为了创建对象，必须先创建它的构造器。虽然创建构造器的开销在实践中可能不那么明显，但是在注重性能情况下，可能出现问题。Builder模式还比重叠构造器模式更加冗长，因此它只在有很多参数的才使用

##### 简而言之

如果类的构造器或者静态工厂中具有多个参数，设计这种累时，**Builder**模式就是种不错的选择，特别是当大多数参数都是可选的手。与重叠构造器模式比易于阅读和编写，构造器也比JavaBeans更加安全。

```
class Movie {

    static Builder newBuilder() {

        return new Builder();

    }

    static class Builder {

        String title;

        Builder withTitle(String title) {

            this.title = title;

            return this;

        }

        Movie build() {

            return new Movie(title);

        }

    }

    private Movie(String title) {

    [...]

    }

}

// Use like this:

Movie matrix = Movie.newBuilder().withTitle("The Matrix").build();

```

#### 避免可变性

不可变性是指对象在整个生命周期内一直保持不变。应将对象中所有对象中所有必要的数据在其创建时就赋值。这个做法有许多好处，比如简洁化，线程安全以及可共享性等。

```java
class Movie{
  [...]
  Movie sequel() {
    return Movie.create(this.title + " 2");
  }
}
// Use like this:
Movie toyStory = Movie.create("Toy Story");
Movie toyStory2 = toyStory.sequel();
```

#### 静态成员类

如果你定义了一个不依赖外部类的内部类，最好将其定义为静态的。否则会导致每一个内部类对象都会持有对外部类的引用。

```java
class Movie {
  [...]
  static class MovieAward {
    [...]
  }
}
```

#### 返回空值

当你方法的返回类型为list/collection时，返回空值时要避免返回null。返回一个空的集合类型，这会使得你简化接口并且避免空指针异常。就返回那个集合的空值，而不是在创建一个。

```java
List<Movie> latestMovies() {
    if (db.query().isEmpty()) {
        return Collections.emptyList();
    }
    [...]
}
```

#### 不要用"+"来连接String

必须要拼接一系列字符串，可能会使用+连字符。永远不要用它来拼接大量字符串，这样的性能很差，考虑使用StringBuilder来代替。

```java
String lastestMovieONeLine(List<Movie> movies) {
  StringBuilder sb = new StringBuilder();
  for(Movie movie : movies) {
    sb.append(movie);
  }
  return sb.toString();
}
```

#### 5.避免创建不必要的对象

一般来说，最好能重用对象而不是在每次需要的时候就创建一个相同功能的新对象。重用方式既快速，又流行.

例如：Map接口的keySet方法，虽然被返回的Set实例一般是可改变的，但是所有返回的对象在功能上是等同的：当一个返回对象发生变化的时候，所有其他返回对象也要发生变化，因为它们都是由同一个Map实例支撑的。

#### 8.覆盖equals时请遵守通用约定

1. 自反性(reflexivity)
2. 对称性(symmetry)
3. 传递性(transitivity)
4. 一致性(consistency)
5. 非空性(Non-nullity)



#### 9.覆盖equals时总要覆盖hashCode

在每个覆盖equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，这样违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。

Object规范

- 在应用程序执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一个对象调用多次，hashCode都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。
- 如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。
- 为不相等的对象产生不相等的散列码

因没有覆盖hashCode而违反的关键约定是第二条：相等的对象必须具有相等的散列码


#### 10.考虑实现Comparable接口
compareTo方法并没有在Object中声明。相反，它是Comparable接口中唯一的方法。compareTo方法不但
允许进行简单的等同性比较，而且允许执行顺序比较，除此之外，它与Object的equals方法具有相似的特征，它还是个泛型。
类实现了Comparable接口，就表明它的实例具有内在的排序关系(natural ordering)。
为实现Comparable接口的对象数组进行排序简单啦：
Arrays.sort(a);
一旦类实现了Comparable接口，它就可以跟许多泛型算法以及依赖于该接口的集合实现进行协作.
事实上，Java平台类库中的所有值类(value classes)都实现了Comparable接口。

```java
public interface Comparable<T> {
    int compareTo(T t)
}
```

compareTo方法的通用约定：
将这个对象与指定的对象进行比较。当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数。

#### 14.在共有类中使用访问方法而非公有域
面向对象编程设计思想的看法：
1. 如果类可以在它所在的包的外部进行访问，就提供访问方法，以保留将来改变该类的内部表示法的灵活性。
如果公有类暴露了它的数据域，要想在将来改变其内部表示法是不可能的，因为共有类的客户端代码已经遍布各处了。
2. 如果累是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误。
3. 让公有类直接暴露域虽然从来都不是种好办法，但是如果域是不可变的，这种做法的危害就比较小。

#### 15.使可变性最小化
不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期(lifetime)内固定不变。
Java平台类库中包含许多不可变的类，其中String、基本类型的包装类、BigInteger和BigDecimal。
为了使类称为不可变类，要遵循下面五条规则：
1. 不要提供任何会修改对象状态的方法。
2. 保证类不会被扩展
3. 使得所有的域都是final的
4. 使得所有的域都称为私有的
5. 确保对于任何可变组件的互斥访问。
如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象
引用来初始化这样的域，也不要从任何访问方法(accessor)中返回该对象引用。

- 不可变对象本质上是线程安全的，它们不要求同步。
    当多个线程并发访问这样的对象时，它们不会遭到破坏。所以不可变对象可以被自由地共享。
- 不仅可以共享不可变对象，甚至也可以共享它们的内部信息。
- 不可变对象为其他对象提供了大量的构件(building blocks)，无论是可变的还是不可变的对象。
- 不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。

#### 16.复合优先于继承
继承(inheritance)是实现代码重用的有力手段，但它并非永远是完成这项工作的最佳工具。
使用不当会导致软件变得很脆弱。在包的内部使用继承是非常安全的，在那里，子类和超类的实现都处于
同一个程序猿的控制下。
* 与方法调用不同的是，继承打破了封装性。
子类依赖于超类中特定功能的实现细节。超类的实现由可能会随着发型版本的不同而有所变化，

包装设计模式(wrapper class)
包装类类不适合用在回调框架(callback framework)中，在回调框架中，对象把自身的引用传递给其他的对象
，用于后续的调用("调用")。因为被包装起来的对象并不知道它外面的包装对象。

只有当子类真正是超类的子类型(subtype)时，才适合用继承

#### 18.接口优于抽象类
Java程序语言提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。
这两种机制之间最明显的区别在于，抽象类允许包含某些方法的实现，但是接口则不允许。
一个更为重要的区别在于，为了实现由抽象类定义的类型，类必须称为抽象类的一个子类。
任何一个类，只要它定义了所有必要的方法，并遵守通用约定，它就被允许实现一个接口，
而不管这个类是出于类层次的哪个位置。因为Java只允许单继承，所以，抽象类作为类型定义受到了极大的限制。

* 现有的类可以很容易被更新，以实现新的接口
* 接口是定义mixin(混合类型)的理想选择。
* 接口允许我们构造非层次结构的类型框架。
虽然接口不允许包含方法的实现，但是，使用接口来定义类型并不妨碍你为程序员提供实现上的帮助。
通过对你导出的每个重要接口都提供一个抽象的骨架实现类，把接口和抽象类的有点结合起来。接口的作用仍然
是定义类型，但是骨架实现类接管了所有与接口实现相关的工作。

骨架实现被称为AbstractInterface，这里的Interface是指所实现的接口的名字。
例如：Collections Framework为每个重要的集合接口都提供了一个骨架实现，包括AbstractCollection、
AbstractSet、AbstractList和AbstractMap。
骨架实现的美妙之处在于，它们为抽象类提供了实现上的帮助，但又不强加“抽象类被用作类型定义时”所持有的严格限制。
对于接口的大多数实现来讲，扩展骨架实现类是个很显然的选择，但并不是必须的。
实现了这个接口的类可以把对于接口方法的调用，转发到一个内部私有类的实例上，这个内部私有类扩展了骨架实现类。
这种方法被称作模拟多重继承。

编写骨架实现类相对比较简单，只是有点单调乏味。首先，必须认真研究接口，并确定哪些方法最为基本，
其他方法则可以根据它们来实现。这些基本将成为骨架实现类中的抽象方法。然后，必须为接口中所有其他的方法提供
具体的实现。

#### 19.接口只用于定义类型
有一种接口被称为常量接口。这种接口没有保护任何方法，它只包含静态final域，没个域都导出一个常量。使用这些常量的类
实现这个接口，以避免用类名来修饰常量名。
常量
