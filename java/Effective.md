# Android 中的 Effective Java

## 强制不可实例化

如果你不希望一个对象通过关键字 *new* 来创建，那么强制让它的**构造方法私有**。这尤其对一些只包含静态方法的工具类有用。

```java
class MovieUtils {
  private MovieUtils() {}

    static String titleAndYear(Movie movie) {
        [...]
    }
}
```

## 静态工厂方法

不要使用new关键字和构造方法创建对象，而应当使用静态工厂方法（和私有构造方法）。这些工厂方法具有名字，需要每次返回一个新的对象实例，它们可以根据需求返回不同的子类型对象。

### 优点

1. 静态工厂方法与构造器不同的优势，它们是有名称的
2. 不必在每次调用它们的时候都创建一个新对象
3. 它们可以返回原返回类型任何子类型的对象（增加了灵活性）
4. 在创建参数化类型实例的时候，它们使得代码变得更加简洁

### 缺点

1. 类如果不含共有的或者受保护的构造器，就不能被子类化。
2. 它们与其他静态方法实际上没有任何区别
   遵守标准的命名习惯，一定量可以弥补这一劣势。
   - valueOf——这样的静态工厂方法实际上是类型转换方法。
   - of——valueOf的一种更为简洁的替代。
   - getInstance——返回的实例是通过方法的参数来描述的，但是不能够说与参数具有同样的值。对于Singleton来说，该方法没有参数，并返回唯一的实例。
   - newInstance——像getInstance一样，但newInstance能够确保返回的每个实例都与所有其他实例不同。
   - getType——像getInstance一样，但在工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型。
   - newType——像newInstance一样，但是工厂方法处于不同的类中的时候使用。Type表示工厂方法所返回的对象类型

```java
class Movie {
    [...]
    public static Movie create(String title) {
        return new Movie(title);
    }
}
```

## 创建者模式

当对象的构造方法参数不小于3个时，可以考虑创建者模式。这可能需要更多行代码，但扩展性和可读性会很好。如果你正创建一个实体类。

### 创建者模式的缺点

为了创建对象，必须先创建它的构造器。虽然创建构造器的开销在实践中可能不那么明显，但是在注重性能情况下，可能出现问题。Builder模式还比重叠构造器模式更加冗长，因此它只在有很多参数的才使用

### 简而言之

如果类的构造器或者静态工厂中具有多个参数，设计这种累时，**Builder**模式就是种不错的选择，特别是当大多数参数都是可选的手。与重叠构造器模式比易于阅读和编写，构造器也比JavaBeans更加安全。

```java
class Movie {

    static Builder newBuilder() {
        return new Builder();
    }

    static class Builder {
        String title;
        Builder withTitle(String title) {
            this.title = title;
            return this;
        }

        Movie build() {
            return new Movie(title);
        }
    }

    private Movie(String title) {
        //[...]
    }

}

// Use like this:
Movie matrix = Movie.newBuilder().withTitle("The Matrix").build();
```

## 避免可变性

不可变性是指对象在整个生命周期内一直保持不变。应将对象中所有对象中所有必要的数据在其创建时就赋值。这个做法有许多好处，比如简洁化，线程安全以及可共享性等。

```java
class Movie{
  [...]
  Movie sequel() {
    return Movie.create(this.title + " 2");
  }
}
// Use like this:
Movie toyStory = Movie.create("Toy Story");
Movie toyStory2 = toyStory.sequel();
```

## 静态成员类

如果你定义了一个不依赖外部类的内部类，最好将其定义为静态的。否则会导致每一个内部类对象都会持有对外部类的引用。

```java
class Movie {
  [...]
  static class MovieAward {
    [...]
  }
}
```

## 返回空值

当你方法的返回类型为list/collection时，返回空值时要避免返回null。返回一个空的集合类型，这会使得你简化接口并且避免空指针异常。就返回那个集合的空值，而不是在创建一个。

```java
List<Movie> latestMovies() {
    if (db.query().isEmpty()) {
        return Collections.emptyList();
    }
    [...]
}
```

## 不要用"+"来连接String

必须要拼接一系列字符串，可能会使用+连字符。永远不要用它来拼接大量字符串，这样的性能很差，考虑使用StringBuilder来代替。

```java
String lastestMovieONeLine(List<Movie> movies) {
  StringBuilder sb = new StringBuilder();
  for(Movie movie : movies) {
    sb.append(movie);
  }
  return sb.toString();
}
```

## 避免创建不必要的对象

一般来说，最好能重用对象而不是在每次需要的时候就创建一个相同功能的新对象。重用方式既快速，又流行.

例如：Map接口的keySet方法，虽然被返回的Set实例一般是可改变的，但是所有返回的对象在功能上是等同的：当一个返回对象发生变化的时候，所有其他返回对象也要发生变化，因为它们都是由同一个Map实例支撑的。

## 覆盖equals时请遵守通用约定

1. 自反性(reflexivity)
2. 对称性(symmetry)
3. 传递性(transitivity)
4. 一致性(consistency)
5. 非空性(Non-nullity)

## 覆盖equals时总要覆盖hashCode

在每个覆盖equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，这样违反Object.hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。

Object规范

- 在应用程序执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对同一个对象调用多次，hashCode都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。
- 如果两个对象根据equals(Object)方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。
- 为不相等的对象产生不相等的散列码

因没有覆盖hashCode而违反的关键约定是第二条：相等的对象必须具有相等的散列码

## 考虑实现Comparable接口

compareTo方法并没有在Object中声明。相反，它是Comparable接口中唯一的方法。compareTo方法不但
允许进行简单的等同性比较，而且允许执行顺序比较，除此之外，它与Object的equals方法具有相似的特征，它还是个泛型。
类实现了Comparable接口，就表明它的实例具有内在的排序关系(natural ordering)。
为实现Comparable接口的对象数组进行排序简单啦：
Arrays.sort(a);
一旦类实现了Comparable接口，它就可以跟许多泛型算法以及依赖于该接口的集合实现进行协作.
事实上，Java平台类库中的所有值类(value classes)都实现了Comparable接口。

```java
public interface Comparable<T> {
    int compareTo(T t)
}
```

compareTo方法的通用约定：
将这个对象与指定的对象进行比较。当该对象小于、等于或大于指定对象的时候，分别返回一个负整数、零或者正整数。

## 在共有类中使用访问方法而非公有域

面向对象编程设计思想的看法：

1. 如果类可以在它所在的包的外部进行访问，就提供访问方法，以保留将来改变该类的内部表示法的灵活性。
    如果公有类暴露了它的数据域，要想在将来改变其内部表示法是不可能的，因为共有类的客户端代码已经遍布各处了。
2. 如果累是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误。
3. 让公有类直接暴露域虽然从来都不是种好办法，但是如果域是不可变的，这种做法的危害就比较小。

## 使可变性最小化

不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期(lifetime)内固定不变。
Java平台类库中包含许多不可变的类，其中String、基本类型的包装类、BigInteger和BigDecimal。
为了使类称为不可变类，要遵循下面五条规则：

1. 不要提供任何会修改对象状态的方法。
2. 保证类不会被扩展
3. 使得所有的域都是final的
4. 使得所有的域都称为私有的
5. 确保对于任何可变组件的互斥访问。

如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。并且，永远不要用客户端提供的对象
引用来初始化这样的域，也不要从任何访问方法(accessor)中返回该对象引用。

- 不可变对象本质上是线程安全的，它们不要求同步。
    当多个线程并发访问这样的对象时，它们不会遭到破坏。所以不可变对象可以被自由地共享。
- 不仅可以共享不可变对象，甚至也可以共享它们的内部信息。
- 不可变对象为其他对象提供了大量的构件(building blocks)，无论是可变的还是不可变的对象。
- 不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。

## 复合优先于继承

继承(inheritance)是实现代码重用的有力手段，但它并非永远是完成这项工作的最佳工具。
使用不当会导致软件变得很脆弱。在包的内部使用继承是非常安全的，在那里，子类和超类的实现都处于
同一个程序猿的控制下

* 与方法调用不同的是，继承打破了封装性。
    子类依赖于超类中特定功能的实现细节。超类的实现由可能会随着发型版本的不同而有所变化，

包装设计模式(wrapper class)
包装类类不适合用在回调框架(callback framework)中，在回调框架中，对象把自身的引用传递给其他的对象
，用于后续的调用("调用")。因为被包装起来的对象并不知道它外面的包装对象。

只有当子类真正是超类的子类型(subtype)时，才适合用继承

## 接口优于抽象类
Java程序语言提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。
这两种机制之间最明显的区别在于，抽象类允许包含某些方法的实现，但是接口则不允许。
一个更为重要的区别在于，为了实现由抽象类定义的类型，类必须称为抽象类的一个子类。
任何一个类，只要它定义了所有必要的方法，并遵守通用约定，它就被允许实现一个接口，
而不管这个类是出于类层次的哪个位置。因为Java只允许单继承，所以，抽象类作为类型定义受到了极大的限制。

* 现有的类可以很容易被更新，以实现新的接口
* 接口是定义mixin(混合类型)的理想选择。
* 接口允许我们构造非层次结构的类型框架。

虽然接口不允许包含方法的实现，但是，使用接口来定义类型并不妨碍你为程序员提供实现上的帮助。
通过对你导出的每个重要接口都提供一个抽象的骨架实现类，把接口和抽象类的有点结合起来。接口的作用仍然
是定义类型，但是骨架实现类接管了所有与接口实现相关的工作。

骨架实现被称为AbstractInterface，这里的Interface是指所实现的接口的名字。
例如：Collections Framework为每个重要的集合接口都提供了一个骨架实现，包括AbstractCollection、
AbstractSet、AbstractList和AbstractMap。
骨架实现的美妙之处在于，它们为抽象类提供了实现上的帮助，但又不强加“抽象类被用作类型定义时”所持有的严格限制。
对于接口的大多数实现来讲，扩展骨架实现类是个很显然的选择，但并不是必须的。
实现了这个接口的类可以把对于接口方法的调用，转发到一个内部私有类的实例上，这个内部私有类扩展了骨架实现类。
这种方法被称作模拟多重继承。

编写骨架实现类相对比较简单，只是有点单调乏味。首先，必须认真研究接口，并确定哪些方法最为基本，
其他方法则可以根据它们来实现。这些基本将成为骨架实现类中的抽象方法。然后，必须为接口中所有其他的方法提供
具体的实现。

## 接口只用于定义类型

有一种接口被称为常量接口。这种接口没有保护任何方法，它只包含静态final域，没个域都导出一个常量。使用这些常量的类
实现这个接口，以避免用类名来修饰常量名。
常量接口模式是对接口的不良使用。
简而言之，接口应该只被用来定义类型，它们不应该被用来导出常量。

### 类层次优于标签类

```java
class Figure{
    enum Shape{RECTANGLE, CIRCLE};

    final Shape shape;
    double length;
    double width;
    double radius;
    Figure(double radius) {
        shape = Shape.CIRCLE;
        this.radius = radius;
    }

    Figure(double length, double width) {
        shape = Shape.RECTANGLE;
        this.length = length;
        this.width = width;
    }

    double area() {
        switch(shape) {
            case RECTANGLE:
                return length * width;
            case CIRCLE:
                return Math.PI * (radius * radius);
            default:
                throw new AssertionError();
        }
    }
}
```

带有两种甚至更多种风格的实例的类，并包含表示实例风格的标签域。
标签类过冗长、容易出错，并且效率低下。
子类型化(subtyping)。标签类是类层次的一种简单的仿效。

为了将标签类转变成类层次:

1. 首先要为标签类中的每个方法都定义一个包含抽象方法的抽象类。
    这每个方法的行为都依赖于标签值。
2. 为每种原始标签类都定义根类的具体子类。

简而言之，标签类很少有适用的时候。当你想要编写一个包含显示标签域的类时，应该考虑一下，这个
标签是否可以被取消，这个类是否可以用类层次来代替。当你遇到一个包含标签域的现有类时，就要考虑将它
重构到一个层次结构中去。

## 用函数对象表示策略

Java没有提供函数指针，但是可以用对象引用实现同样的功能。
调用对象上的方法通常是执行该对象的操作。然而，我们有可能定义这样一种对象，它的方法执行其他对象上的操作。
如果一个类仅仅导出这样的一个方法，它的实例实际上就等同于一个指向该方法的指针。这样的实例被称为函数对象(function object)。

简而言之，函数指针的主要用途就是实现策略(Strategy)模式。为了在Java中实现这种模式，要声明一个接口来表示该策略，
并且为每个具体策略声明一个实现了该接口的类。当一个具体策略只被使用一次时，通常使用匿名类来声明和实例化这个具体
策略类。当一个具体策略是设计用来重复使用的时候，它的类通常就要被实现为私有的静态成员类，并通过共有的静态final域被导出，
其类型为该策略接口。

## 优先考虑静态成员类

**嵌套类**(nested class)是指被定义在另一个类的内部类。嵌套类存在的目的应该只是为它的外围类提供服务(enclosing class)
提供服务。如果嵌套类将来可能会用于其他的某个环境中，它就应该是顶层类(top-level class)。
嵌套类有四种：

1. 静态成员类(static member class)
2. 非静态成员类(monstatic member class)
3. 匿名类(anonymous class)
4. 局部类(local class) 除了第一种之外，其他三种都被称为内部类(inner class)

静态成员类是最简单的一种嵌套类。最好把它看作是普通的类，只是碰巧被声明在另一个类的内部而已，
它可以访问外围类的所有成员，包括那些声明为私有的成员。静态成员是外围类的一个静态成员，
与其他静态成员一样，也遵守同样的可访问性规则。如果它被声明为私有的，它就只能在外围类的内部才可以被访问，等等。
静态成员类的一种常见用法是作为公有的辅助类，仅当与它的外部类一起使用时才有意义。

从语法来讲，静态成员类和非静态成员类之间唯一的区别是，静态成员类的声明中包含修饰符static。尽管它们的语法非常相似，
但是这两种嵌套类有很大的不同。非静态成员类的每个实例都隐含着与外围类的一个`外围实例`(enclosing instance)相关联。
在非静态成员类的实例方法内部，可以调用外围实例上的方法，或者利用修饰过的this构造获得外围实例的引用。
如果嵌套类的实例可以在它外围类的实例之外独立存在，这个嵌套类就必须是静态成员类。

当非静态成员类的实例被创建的时候，它和外围实例之间的关联关系也随之被建立起来；
而且，这种关联关系以后不能被修改。通常情况下，当在外围类的某个实例方法的内部调用非静态成员类的构造器时，这种关联关系被自动建立起来。
使用表达式enclosingInstance来手工建立这种关系也是有可能的，但是很少使用。

非静态成员类的一种常见用法是定义一个Adapter，它允许外部类的实例看作是另一个不相关的类的实例。

**如果声明成员类不要求访问外围实例，就要始终把static修饰放在它的声明中**，使它成为静态成员类，
而不是非静态成员类。如果省略了static修饰符，则每个实例都包含了一个额外的指向外围对象的引用。
保存这份引用要消耗时间和空间，并且会导致外围实例在符合垃圾回收时却仍然得以保留。如果在没有外围实例的情况下，
也需要分配实例，就不能使用非静态成员类，因为非静态成员类的实例必须要有一个外围实例。

私有静态成员类的一种常见用法是用来外表外围类所代表的对象的组件。

匿名类不同于Java程序设计语言中的其它任何语法单元。匿名类没有名字。它不是外围类的一个成员。
它并不与其他成员一起呗声明，而是在使用的同时被声明和实例化。匿名类可以出现在代码中任何允许存在表达式
的地方。当且仅当匿名类出现在非静态的环境中时，它才有外围实例。但是即使它们出现在静态的环境中，也不可能
拥有任何静态成员。

匿名类的适用性受到诸多的限制。除了在她们被声明的时候之外，是无法将它们实例化的。你不能执行instanceof测试，
或者做任何需要命名类的其他事情。你无法声明一个匿名类来实现多个接口。或者扩展一个类，
并同时扩展和实现接口。匿名类的客户端无法调用任何成员，除了从它的超类型中继承得到之外。它们必须
保持简短————大约10行或者更少些————否则会影响程序的可读性。

匿名类的一种常见用法：

1. 动态地创建函数对象。
2. 创建过程对象
3. 静态工厂方法的内部.

局部类是四种嵌套类中用的最少的类。局部类与其他三种嵌套类的每一种都一些共同的属性。
与成员类一样，局部类有名字，可以被重复地使用。与匿名类一样，只有当局部类是在非静态环境中
定义的时候，才有外围实例，它们也不能包含静态成员。与匿名类一样，它们必须非常简短，以便不会影响到可读性。

简而言之，有四种不同的嵌套类.
如果一个嵌套类需要在单个方法之外仍然是可见的，或者它太长了，不适合于放在方法内部，就应该使用成员类。
如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的；否则，就做成静态的。
假设这个嵌套类属于一个方法的内部，如果你只需要在一个地方创建实例，并且已经有了一个预置的类型可以说明这个类
的特征，就要把它做成匿名类；否则，就做成局部类。

## 列表优先于数组

数组和泛型相比，有两个重要的不同点。

1. 数组是协变的(convariant)，其实只是表示如果Sub为Super的子类型，那么数组类型Sub[]就是Super的子类型。
    相反，泛型则是不可变的(invariant)：对于任意两个不同的类型Type1和Type2，`List<Type1>`既不是`List<Type2>`的
    子类型，也不是`List<Type2>`的超类型。
2. 数组与泛型之间的第二区别在于，数组是**具体化**。因此数组会在运行时才知道并检查它们的元素类型约束。
    泛型则是通过擦除(erasure)来实现的。因此泛型只在编译时强化它们的类型信息，并在运行时丢弃它们的元素信息。

总而言之，数据和泛型有着非常不同的类型规则。数组是协变且可以具体化；泛型是不可变的且可以被擦除。因此，数组提供
了运行时的类型安全，但是没有编译时的类型安全，反之，对于泛型也一样。一般来说，数组和泛型不能很好的混合使用。

## 优先考虑类型安全的异构容器

泛型最常用于集合，如Set和Map，以及单元素的容器，如ThreadLocal和AtomicReference。
在这些用法中，它都充当被参数化了的容器。这样就限制你每个容器只能有固定数据的参数类型。
这样就限制你每个容器只能有固定数目的类型参数。

但是，有时候你会需要更多的灵活性。例如,数据库行可以有任意多的列，如果能以类型安全的方式访问所有列就好了。
这种想法就是将键(key)进行参数化而不是容器(container)参数化。然后将参数化的键提交给容器，来插入或者获取值。
用泛型系统来确保值的类型与它的键相符。

例如:

```java
public class Favorites {
    public <T> void putFavorite(Class<T> type, T instance);
    public <T> T getFavorite(Class<T> type);
}
```

Favorites实例是`类型安全的(typesafe)`的：当你向它请求String的时候，它从来不会返回Integer给你，同时它也是异构的
(*heterogeneous*)：不像普通的map，它的所有键都是不同类型的，因此，我们将Favorites称为
`类型安全的异构容器(typesafe heterogeneous container)`。

Favorites的完整实现如下：

```java
public class Favorites {
    private Map<Class<?>, Object> favorites = new HashMap<Class<?>, Object>();

    public <T> void putFavorite(Class<T> type, T instance) {
        if (type == null)
            throw new NullPointerException("Type is null")
        favorites.put(type, instance);
    }

    public <T> T getFavorite(Class<T> type){
        return type.cast(favorites.get(type));
    }
}
```

1. 每个Favorites实例都得到一个称作favorites的私有Map<Class<?>, Object>的支持。你可能认为无限通配符类型的关系，将不能把任何东西放进这个
    Map中，但事实正好相反。要注意的是通配符了下的嵌套的：它不是属于通配符类型的Map的类型，而是它的键的类型。
    由此可见，每个键都可以有一个不同的参数化类型：一个可以是`Class<String>`，接下来是Class<Integer>
    等等。异构就是从这里来的。

2. favorites Map的值类型知识Object，换句话说，Map并不能保证键与值之间的类型关系，即不能保证每个值的类型都与键的类型相同。

Favorites类有两种局限性值得注意。首先，恶意的客户端可以很轻松地破坏Favorites实例的类型安全。
第二种局限在于它不能用在不可具体化的(non-reifiable)类型中。换句话说，你可以保存最喜爱的String和
String[]，但不能保存最喜爱的`List<String>`。如果试图保存最喜爱的List<String>，程序就不能进行编译

注解API广泛利用了有限制的类型令牌

```java
public <T extend Annotation>
    T getAnnotation(Class<T> annotationType)
```

参数annotationType是一个表示注解类型的有限制的类型令牌。如果元素有这种类型的注解，该方法就
将它返回，如果没有，则返回null。被注解的元素本质上是个类型安全的异构容器，容器的键属于注解类型。